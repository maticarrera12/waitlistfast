
generator client {
  provider = "prisma-client"
  output   = "../src/generated"
}

datasource db {
  provider = "postgresql"
}

enum PlanType {
  STARTER
  PRO
  BUSINESS
}

enum PlanStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  TRIALING
  PAUSED
}

enum SubscriptionProvider {
  LEMONSQUEEZY
}

enum PurchaseType {
  SUBSCRIPTION
}

enum PurchaseStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
  CANCELED
}

enum PlanInterval {
  MONTHLY
  YEARLY
}

enum DomainStatus {
  ACTIVE
  DISABLED
  RESERVED
}

enum ReferralStatus {
  CLICKED
  SIGNUP_STARTED
  COMPLETED
  VERIFIED
  CONFIRMED
  REJECTED
}

enum PointReason {
  SIGNUP
  REFERRAL_CONFIRMED
  BONUS_ACTION
  REWARD
  PENALTY
  ADJUSTMENT
}

enum RewardType {
  FEATURE
  ACCESS
  DISCOUNT
  PHYSICAL
  CUSTOM
}

enum RewardMode {
  POSITION_BASED
  TIER_BASED
  ACTION_BASED
}

enum RewardStability {
  LOCKED
  DYNAMIC
  SNAPSHOT
}

enum RewardStatus {
  LOCKED
  UNLOCKED
  CLAIMED
  REVOKED
}

enum CampaignStatus {
  DRAFT
  ACTIVE
  PAUSED
  ENDED
}

enum ScoringMode {
  POINTS
  REFERRALS_ONLY
}

enum RewardDistributionRule {
  TOP_N
  MIN_SCORE
  MIN_REFERRALS
  MANUAL
}

enum PointEvent {
  SIGNUP
  REFERRAL_CONFIRMED
  EMAIL_VERIFIED
  MILESTONE
  MANUAL
}

model User {
  id            String    @id @default(cuid())
  name          String?   @unique
  email         String?   @unique
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  emailVerified Boolean   @default(false)
  image         String?
  role          String    @default("user")
  banned        Boolean   @default(false)
  banReason     String?
  banExpires    DateTime?
  sessions      Session[]
  accounts      Account[]
  members       Member[]
  invitations   Invitation[]
  purchases     Purchase[]

  plan          PlanType    @default(STARTER)
  planStatus    PlanStatus  @default(ACTIVE)

  subscriptionProvider   SubscriptionProvider?
  subscriptionId         String?   @unique
  currentPeriodStart     DateTime?
  currentPeriodEnd       DateTime?
  cancelAtPeriodEnd      Boolean   @default(false)

  lemonSqueezyCustomerId String?   @unique
  lemonSqueezyVariantId  String?

  @@index([email])
  @@index([plan])
  @@index([lemonSqueezyCustomerId])
  @@map("user")
}

model Session {
  id                   String        @id
  expiresAt            DateTime
  token                String
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt
  ipAddress            String?
  userAgent            String?
  userId               String
  user                 User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  activeOrganizationId String?
  activeOrganization   Organization? @relation(fields: [activeOrganizationId], references: [id])

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([identifier])
  @@map("verification")
}

model Organization {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  logo      String?
  metadata  Json?

  members      Member[]
  invitations  Invitation[]
  sessions     Session[]
  waitlists    Waitlist[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slug])
  @@map("organization")
}

model Member {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           String       @default("member") 

  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  @@unique([organizationId, userId])
  @@index([userId])
  @@index([organizationId])
  @@map("member")
}
model Invitation {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  email          String
  role           String?
  status         String       @default("pending")
  expiresAt      DateTime
  inviterId      String
  user           User         @relation(fields: [inviterId], references: [id], onDelete: Cascade)
  createdAt      DateTime     @default(now())

  @@map("invitation")
}

model Purchase {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type     PurchaseType
  provider SubscriptionProvider

  plan    PlanType?

  amount   Int      
  currency String   @default("usd")

  providerPaymentId      String   @unique 
  providerProductId      String?
  providerCustomerId     String?
  providerSubscriptionId String?

  metadata Json? 

  status PurchaseStatus

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model Waitlist {
  id            String        @id @default(cuid())

  name          String      
  slug          String @unique  

  headline      String?       
  description   String?       @db.Text
  domainStatus  DomainStatus @default(ACTIVE)
  domainSettings Json?

  settings      Json?         

  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  subscribers       Subscriber[]
  referrals         Referral[]
  rankingSnapshots  RankingSnapshot[]
  rewardRules       RewardRule[]
  referralCampaigns ReferralCampaign[]
  pointRules        PointRule[]

  createdAt     DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@index([organizationId])
  @@map("waitlist")
}

model Subscriber {
  id            String   @id @default(cuid())
  email         String

  referralCode  String   @unique

  verified      Boolean  @default(false)

  waitlistId    String
  waitlist      Waitlist @relation(fields: [waitlistId], references: [id], onDelete: Cascade)

  referredById  String?
  referredBy    Subscriber? @relation("ReferralTree", fields: [referredById], references: [id])
  referrals     Subscriber[] @relation("ReferralTree")

  score         Int      @default(0) 
  position      Int?     

  metadata      Json?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  referralsAsReferrer    Referral[]        @relation("Referrer")
  referralsAsReferred    Referral[]        @relation("Referred")
  pointLedgers           PointLedger[]
  rankingSnapshots       RankingSnapshot[]
  rewardAssignments      RewardAssignment[]
  subscriberRewards      SubscriberReward[]

  @@unique([waitlistId, email])
  @@index([waitlistId])
  @@index([referredById])
  @@index([waitlistId, score]) 
  @@map("subscriber")
}

model Referral {
  id            String @id @default(cuid())

  waitlistId    String
  waitlist      Waitlist @relation(fields: [waitlistId], references: [id], onDelete: Cascade)

  referrerId    String
  referrer      Subscriber @relation("Referrer", fields: [referrerId], references: [id], onDelete: Cascade)

  referredEmail String
  referredId    String?
  referred      Subscriber? @relation("Referred", fields: [referredId], references: [id])

  status        ReferralStatus

  source        String? 
  ipAddress     String?
  userAgent     String?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([referrerId])
  @@index([status])
  @@index([waitlistId])
  @@map("referral")
}

model PointLedger {
  id            String @id @default(cuid())

  subscriberId  String
  subscriber    Subscriber @relation(fields: [subscriberId], references: [id], onDelete: Cascade)

  campaignId    String
  campaign      ReferralCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  event         PointEvent

  points        Int

  referenceId   String?

  metadata      Json?

  createdAt     DateTime @default(now())

  @@index([subscriberId])
  @@index([campaignId])
  @@index([event])
  @@index([campaignId, subscriberId]) 
  @@map("point_ledger")
}

model RankingSnapshot {
  id           String @id @default(cuid())

  waitlistId   String
  waitlist     Waitlist @relation(fields: [waitlistId], references: [id], onDelete: Cascade)

  subscriberId String
  subscriber   Subscriber @relation(fields: [subscriberId], references: [id], onDelete: Cascade)

  position     Int
  score        Int

  calculatedAt DateTime @default(now())
  isFinal      Boolean  @default(false)

  @@index([waitlistId, position])
  @@index([waitlistId, calculatedAt])
  @@index([subscriberId])
  @@map("ranking_snapshot")
}

model RewardRule {
  id            String @id @default(cuid())

  waitlistId    String
  waitlist      Waitlist @relation(fields: [waitlistId], references: [id], onDelete: Cascade)

  name          String
  description   String?

  type          RewardType
  mode          RewardMode
  stability     RewardStability

  minPosition   Int?
  maxPosition   Int?

  minReferrals  Int?

  rewardData    Json 

  startsAt      DateTime?
  endsAt        DateTime?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  rewardAssignments RewardAssignment[]

  @@index([waitlistId])
  @@index([mode])
  @@map("reward_rule")
}

model RewardAssignment {
  id            String @id @default(cuid())

  rewardRuleId  String
  rewardRule    RewardRule @relation(fields: [rewardRuleId], references: [id], onDelete: Cascade)

  subscriberId  String
  subscriber    Subscriber @relation(fields: [subscriberId], references: [id], onDelete: Cascade)

  status        RewardStatus

  assignedAt    DateTime @default(now())
  claimedAt      DateTime?

  metadata      Json?

  @@index([subscriberId])
  @@index([rewardRuleId])
  @@index([status])
  @@map("reward_assignment")
}

model ReferralCampaign {
  id        String   @id @default(cuid())

  waitlistId String
  waitlist   Waitlist @relation(fields: [waitlistId], references: [id], onDelete: Cascade)

  name      String
  status    CampaignStatus @default(DRAFT)

  settings  Json

  startsAt  DateTime?
  endsAt    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  rewards      Reward[]
  pointLedgers PointLedger[]

  @@index([waitlistId, status]) 
  @@index([status])
  @@map("referral_campaign")
}

model Reward {
  id            String   @id @default(cuid())

  campaignId    String
  campaign      ReferralCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)

  name          String
  description   String?  @db.Text

  type          RewardType

  distributionRule RewardDistributionRule

  ruleParams    Json

  payload       Json

  maxRecipients Int?    

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  subscriberRewards SubscriberReward[]

  @@index([campaignId])
  @@map("reward")
}

model SubscriberReward {
  id            String   @id @default(cuid())

  subscriberId  String
  subscriber    Subscriber @relation(fields: [subscriberId], references: [id], onDelete: Cascade)

  rewardId      String
  reward        Reward @relation(fields: [rewardId], references: [id], onDelete: Cascade)

  status        RewardStatus @default(LOCKED)

  unlockedAt    DateTime?

  deliveredAt   DateTime?

  metadata      Json?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([subscriberId, rewardId]) 
  @@index([subscriberId])
  @@index([rewardId])
  @@index([status])
  @@map("subscriber_reward")
}

model PointRule {
  id            String   @id @default(cuid())

  waitlistId    String
  waitlist      Waitlist @relation(fields: [waitlistId], references: [id], onDelete: Cascade)

  event         PointEvent

  points        Int

  conditions    Json?

  name          String?
  description   String?

  isActive      Boolean  @default(true)

  priority      Int      @default(0)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([waitlistId, event, isActive])
  @@index([waitlistId])
  @@map("point_rule")
}